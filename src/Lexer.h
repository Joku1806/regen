#pragma once

#include "Token.h"
#include <array>
#include <cstdint>
#include <string>
#include <string_view>
#include <vector>

constexpr std::array<std::array<bool, NUMBER_OF_TOKEN_KINDS>,
                     NUMBER_OF_TOKEN_KINDS>
make_grammar_allowed() {
  std::array<std::array<bool, NUMBER_OF_TOKEN_KINDS>, NUMBER_OF_TOKEN_KINDS>
      res{};

  res[Alternator][Escape] = true;
  res[Alternator][Literal] = true;
  res[Alternator][LiteralRangeOpen] = true;
  res[Alternator][SubgroupOpen] = true;

  res[Literal][Alternator] = true;
  res[Literal][Escape] = true;
  res[Literal][Literal] = true;
  res[Literal][LiteralRangeClose] = true;
  res[Literal][LiteralRangeOpen] = true;
  res[Literal][RangeArgumentSeparator] = true;
  res[Literal][Repeat0_1] = true;
  res[Literal][Repeat0_Inf] = true;
  res[Literal][Repeat1_Inf] = true;
  res[Literal][RepetitionRangeClose] = true;
  res[Literal][RepetitionRangeOpen] = true;
  res[Literal][SubgroupClose] = true;
  res[Literal][SubgroupOpen] = true;

  res[LiteralRangeClose][Alternator] = true;
  res[LiteralRangeClose][Escape] = true;
  res[LiteralRangeClose][Literal] = true;
  res[LiteralRangeClose][LiteralRangeOpen] = true;
  res[LiteralRangeClose][Repeat0_1] = true;
  res[LiteralRangeClose][Repeat0_Inf] = true;
  res[LiteralRangeClose][Repeat1_Inf] = true;
  res[LiteralRangeClose][RepetitionRangeOpen] = true;
  res[LiteralRangeClose][SubgroupClose] = true;
  res[LiteralRangeClose][SubgroupOpen] = true;

  res[LiteralRangeOpen][Escape] = true;
  res[LiteralRangeOpen][Literal] = true;

  res[Number][RangeArgumentSeparator] = true;
  res[Number][RepetitionRangeClose] = true;

  // FIXME: Maybe have two types of ArgumentSeparators,
  // one for each range
  res[RangeArgumentSeparator][Escape] = true;
  res[RangeArgumentSeparator][Literal] = true;
  res[RangeArgumentSeparator][Number] = true;
  res[RangeArgumentSeparator][RepetitionRangeClose] = true;

  res[Repeat0_1][Alternator] = true;
  res[Repeat0_1][Escape] = true;
  res[Repeat0_1][Literal] = true;
  res[Repeat0_1][LiteralRangeOpen] = true;
  res[Repeat0_1][SubgroupClose] = true;
  res[Repeat0_1][SubgroupOpen] = true;

  res[Repeat0_Inf][Alternator] = true;
  res[Repeat0_Inf][Escape] = true;
  res[Repeat0_Inf][Literal] = true;
  res[Repeat0_Inf][LiteralRangeOpen] = true;
  res[Repeat0_Inf][SubgroupClose] = true;
  res[Repeat0_Inf][SubgroupOpen] = true;

  res[Repeat1_Inf][Alternator] = true;
  res[Repeat1_Inf][Escape] = true;
  res[Repeat1_Inf][Literal] = true;
  res[Repeat1_Inf][LiteralRangeOpen] = true;
  res[Repeat1_Inf][SubgroupClose] = true;
  res[Repeat1_Inf][SubgroupOpen] = true;

  res[RepetitionRangeClose][Alternator] = true;
  res[RepetitionRangeClose][Escape] = true;
  res[RepetitionRangeClose][Literal] = true;
  res[RepetitionRangeClose][LiteralRangeOpen] = true;
  res[RepetitionRangeClose][SubgroupClose] = true;
  res[RepetitionRangeClose][SubgroupOpen] = true;

  res[RepetitionRangeOpen][Number] = true;
  res[RepetitionRangeOpen][RangeArgumentSeparator] = true;

  res[SubgroupClose][Alternator] = true;
  res[SubgroupClose][Escape] = true;
  res[SubgroupClose][Literal] = true;
  res[SubgroupClose][LiteralRangeOpen] = true;
  res[SubgroupClose][Repeat0_1] = true;
  res[SubgroupClose][Repeat0_Inf] = true;
  res[SubgroupClose][Repeat1_Inf] = true;
  res[SubgroupClose][RepetitionRangeOpen] = true;
  res[SubgroupClose][SubgroupClose] = true;
  res[SubgroupClose][SubgroupOpen] = true;

  res[SubgroupOpen][Escape] = true;
  res[SubgroupOpen][Literal] = true;
  res[SubgroupOpen][LiteralRangeOpen] = true;
  res[SubgroupOpen][SubgroupOpen] = true;

  return res;
}

enum LexMode {
  Default,
  InLiteralRange,
  InRepetitionRange,
};

class Lexer {
public:
  Lexer(const std::string &regex) : m_view(std::string_view(regex)) {
    m_mode = Default;
    m_currently_open_subgroups = 0;
    m_currently_lexed_range_values = 0;
  }
  std::vector<Token *> lex();

private:
  // Provides a compact and fool-proof way of checking which kinds of tokens
  // are allowed after one another. For example,
  // [Alternator][Literal] = true means that an Alternator
  // can be followed by a Literal. Everything that is not set in this 2D array
  // is not syntactically correct. These rules don't include the Concatenator
  // operator as well as any whitespace for the following reasons:
  //
  // 1. Concatenator: This is only helpful for the AST generation and can't be
  // generated by user input itself.
  // 2. Whitespace: Doesn't carry any information and wouldn't do any harm to be
  // included, but is supposed to be stripped by the lexer.
  //
  // In both cases, not including them in the table serves as a kind of tripwire
  // for knowing that something is seriously wrong with our symbol
  // detection/lexing routine :^)
  static constexpr std::array<std::array<bool, NUMBER_OF_TOKEN_KINDS>,
                              NUMBER_OF_TOKEN_KINDS>
      m_grammar_allowed = make_grammar_allowed();
  LexMode m_mode;
  TokenKind m_previous;
  TokenKind m_current;
  uint32_t m_currently_open_subgroups;
  uint32_t m_currently_lexed_range_values;
  std::string_view m_view;
  std::vector<Token *> m_tokens;

  // Tries to convert commonly encoded characters such as \n, \t, etc...
  // to their actual ASCII value. Returns {} if symbol is not one of those
  // characters. This method makes it possible to distinguish these kinds of
  // characters from normal escaped symbols, that would otherwise be interpreted
  // as part of the regex grammar.
  std::optional<char> convert_reserved_ASCII_character();
  TokenKind identify_current_token_kind();
  void handle_token_in_RepetitionRange();
  void handle_token_in_LiteralRange();
  void handle_escaped_token();
};